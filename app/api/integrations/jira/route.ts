import { NextRequest, NextResponse } from 'next/server';
import type { JiraManualTicketData, JiraTicketData, DevTeam } from '@/app/features/social/lib/aiTypes';

// JIRA API configuration
const JIRA_BASE_URL = 'https://kazimi.atlassian.net';
const JIRA_PROJECT_KEY = 'KAN';
const JIRA_EMAIL = 'kazim.salikhov@gmail.com'; // Required for basic auth with API token

// Map severity to JIRA priority IDs (Atlassian uses numeric IDs)
const PRIORITY_MAP: Record<string, string> = {
  highest: '1',
  high: '2',
  medium: '3',
  low: '4',
  lowest: '5',
};

// Map issue types to JIRA IDs (standard Jira issue types)
const ISSUE_TYPE_MAP: Record<string, string> = {
  bug: '10006',      // Bug
  story: '10001',    // Story
  task: '10002',     // Task
  improvement: '10003', // Improvement/Enhancement
};

// Map DevTeam to JIRA component names (you may need to create these in JIRA)
const TEAM_TO_COMPONENT: Partial<Record<DevTeam, string>> = {
  frontend: 'Frontend',
  backend: 'Backend',
  mobile: 'Mobile',
  platform: 'Platform',
  data: 'Data',
  payments: 'Payments',
  search: 'Search',
  notifications: 'Notifications',
  security: 'Security',
  localization: 'Localization',
  'customer-success': 'Customer Success',
  growth: 'Growth',
};

interface CreateTicketRequest {
  feedbackId: string;
  ticket: JiraManualTicketData | JiraTicketData;
  assignedTeam?: DevTeam;
  // Optional fields for Stage 1 simple tickets
  simple?: boolean;
}

interface JiraCreateResponse {
  id: string;
  key: string;
  self: string;
}

/**
 * Build JIRA ticket description from JiraManualTicketData (detailed) or JiraTicketData (simple)
 */
function buildTicketDescription(
  ticket: JiraManualTicketData | JiraTicketData,
  feedbackId: string,
  isDetailed: boolean
): string {
  let description = '';

  if (isDetailed) {
    const detailed = ticket as JiraManualTicketData;
    
    // Main description
    description += `h2. Description\n${detailed.description}\n\n`;

    // Steps to reproduce (for bugs)
    if (detailed.stepsToReproduce && detailed.stepsToReproduce.length > 0) {
      description += `h2. Steps to Reproduce\n`;
      detailed.stepsToReproduce.forEach((step, i) => {
        description += `# ${step}\n`;
      });
      description += '\n';
    }

    // Expected vs Actual behavior
    if (detailed.expectedBehavior) {
      description += `h2. Expected Behavior\n${detailed.expectedBehavior}\n\n`;
    }
    if (detailed.actualBehavior) {
      description += `h2. Actual Behavior\n${detailed.actualBehavior}\n\n`;
    }

    // Technical context
    description += `h2. Technical Context\n${detailed.technicalContext}\n\n`;

    // Blockers
    if (detailed.blockers && detailed.blockers.length > 0) {
      description += `h2. Blockers / Missing Information\n`;
      detailed.blockers.forEach(blocker => {
        description += `* ${blocker}\n`;
      });
      description += '\n';
    }

    // Suggested approach
    if (detailed.suggestedApproach) {
      description += `h2. Suggested Approach\n${detailed.suggestedApproach}\n\n`;
    }

    // Acceptance criteria
    description += `h2. Acceptance Criteria\n`;
    detailed.acceptanceCriteria.forEach(ac => {
      description += `* ${ac}\n`;
    });
    description += '\n';
  } else {
    const simple = ticket as JiraTicketData;
    description += `h2. Description\n${simple.description}\n\n`;
    description += `h3. Area: ${simple.area}\n`;
    description += `h3. Severity: ${simple.severity}\n`;
    description += `h3. Estimated Effort: ${simple.effort}\n\n`;
  }

  // Metadata
  description += `----\n`;
  description += `_Created from feedback ID: ${feedbackId}_\n`;
  description += `_Generated by AI Agent at ${new Date().toISOString()}_`;

  return description;
}

/**
 * POST /api/integrations/jira
 * Creates a JIRA ticket in the KAN project
 */
export async function POST(request: NextRequest) {
  try {
    const body: CreateTicketRequest = await request.json();
    const { feedbackId, ticket, assignedTeam, simple = false } = body;

    // Validate required fields
    if (!feedbackId) {
      return NextResponse.json(
        { error: 'feedbackId is required' },
        { status: 400 }
      );
    }

    if (!ticket || !ticket.summary) {
      return NextResponse.json(
        { error: 'ticket data with summary is required' },
        { status: 400 }
      );
    }

    // Get JIRA API token from environment
    const jiraToken = process.env.JIRA_API_TOKEN;
    if (!jiraToken) {
      console.error('[JIRA API] JIRA_API_TOKEN not configured');
      return NextResponse.json(
        { error: 'JIRA integration not configured. Please add JIRA_API_TOKEN to environment.' },
        { status: 500 }
      );
    }

    // Build description based on ticket type
    const isDetailed = 'issueType' in ticket;
    const description = buildTicketDescription(ticket, feedbackId, isDetailed);

    // Determine issue type
    let issueTypeId = ISSUE_TYPE_MAP['task']; // Default
    if (isDetailed) {
      const detailed = ticket as JiraManualTicketData;
      issueTypeId = ISSUE_TYPE_MAP[detailed.issueType] || ISSUE_TYPE_MAP['task'];
    }

    // Determine priority
    let priorityId = PRIORITY_MAP['medium']; // Default
    if (isDetailed) {
      const detailed = ticket as JiraManualTicketData;
      priorityId = PRIORITY_MAP[detailed.priority] || PRIORITY_MAP['medium'];
    } else {
      const simple = ticket as JiraTicketData;
      // Map severity to priority
      const severityToPriority: Record<string, string> = {
        critical: 'highest',
        major: 'high',
        minor: 'medium',
        trivial: 'low',
      };
      priorityId = PRIORITY_MAP[severityToPriority[simple.severity]] || PRIORITY_MAP['medium'];
    }

    // Prepare labels
    const labels: string[] = ['ai-generated'];
    if (isDetailed) {
      const detailed = ticket as JiraManualTicketData;
      if (detailed.labels) {
        labels.push(...detailed.labels);
      }
    }
    if (assignedTeam) {
      labels.push(`team-${assignedTeam}`);
    }

    // Prepare the JIRA API request
    const jiraPayload = {
      fields: {
        project: {
          key: JIRA_PROJECT_KEY,
        },
        summary: ticket.summary.substring(0, 255), // JIRA has max 255 chars for summary
        description: description,
        issuetype: {
          id: issueTypeId,
        },
        priority: {
          id: priorityId,
        },
        labels: labels,
      },
    };

    console.log(`[JIRA API] Creating ticket for feedback ${feedbackId}:`, {
      summary: ticket.summary,
      issueType: issueTypeId,
      priority: priorityId,
    });

    // Create Basic Auth header (email:api_token base64 encoded)
    const auth = Buffer.from(`${JIRA_EMAIL}:${jiraToken}`).toString('base64');

    // Create the ticket via JIRA API
    const response = await fetch(
      `${JIRA_BASE_URL}/rest/api/3/issue`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${auth}`,
          'Accept': 'application/json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(jiraPayload),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`[JIRA API] Failed to create ticket:`, {
        status: response.status,
        statusText: response.statusText,
        error: errorText,
      });
      return NextResponse.json(
        {
          error: `JIRA API error: ${response.status} ${response.statusText}`,
          details: errorText,
        },
        { status: response.status }
      );
    }

    const createdTicket: JiraCreateResponse = await response.json();
    
    console.log(`[JIRA API] Successfully created ticket ${createdTicket.key}:`, 
      `${JIRA_BASE_URL}/browse/${createdTicket.key}`
    );

    return NextResponse.json({
      success: true,
      feedbackId,
      ticket: {
        id: createdTicket.id,
        key: createdTicket.key,
        url: `${JIRA_BASE_URL}/browse/${createdTicket.key}`,
      },
    });
  } catch (error) {
    console.error('[JIRA API] Unexpected error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

/**
 * GET /api/integrations/jira
 * Check JIRA integration status
 */
export async function GET() {
  const hasToken = !!process.env.JIRA_API_TOKEN;

  return NextResponse.json({
    status: hasToken ? 'configured' : 'not_configured',
    baseUrl: JIRA_BASE_URL,
    projectKey: JIRA_PROJECT_KEY,
  });
}
